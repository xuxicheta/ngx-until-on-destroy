import { UntilOnDestroy } from './until-on-destroy';
import { timer, Observable, of } from 'rxjs';
import { mapTo, finalize } from 'rxjs/operators';
import { OnDestroy, OnInit } from '@angular/core';
import { fakeAsync, tick } from '@angular/core/testing';

class FakeComponent implements OnDestroy, OnInit {
  request = (value: any) => timer(300).pipe(mapTo(value));

  @UntilOnDestroy()
  subscribeRequest(value: any, cb: any = () => { }) {
    return this.request(value).subscribe(cb);
  }

  @UntilOnDestroy()
  subscribeCustomObservable(obs$: Observable<any>, cb: any = () => { }) {
    return obs$.subscribe(cb);
  }

  ngOnDestroy() { }
  ngOnInit() { }
}

function setup() {
  const component = new FakeComponent();
  component.ngOnInit();
  return { component };
}


describe('UntilOnDestroy.decorator', () => {
  it('should not break ordinary work', fakeAsync(() => {
    // arrange
    const { component } = setup();
    const cb = jasmine.createSpy('cb');
    const value = Math.random();
    // act
    component.subscribeRequest(value, cb);
    tick(400);
    // assert
    expect(cb.calls.count()).toEqual(1);
    expect(cb.calls.argsFor(0)).toEqual([value]);
  }));

  it('should complete decorated subscriptions at ngOnDestroy', fakeAsync(() => {
    // arrange
    const { component } = setup();
    const value = Math.random();
    const cb = jasmine.createSpy('cb');
    const spycomplete = jasmine.createSpy('spycomplete');
    const obs$ = timer(300).pipe(mapTo(value), finalize(spycomplete));
    // act
    const sub = component.subscribeCustomObservable(obs$, cb);
    tick(100);
    component.ngOnDestroy();
    // assert
    expect(cb.calls.count()).toEqual(0);
    expect(spycomplete.calls.count()).toEqual(1);
    expect(sub.closed).toBeTruthy();
  }));

  it('should throw error if there are not ngOnInit', () => {
    // arrange
    const resultFn = () => {
      class NoInitComponent implements OnDestroy {
        ngOnDestroy() { }

        @UntilOnDestroy()
        obs() {
          return of(null).subscribe();
        }
      }
    };
    // assert
    expect(resultFn).toThrowError(`You have to implements ngOnInit in component NoInitComponent`);
  });

  it('should throw error if there are not ngOnDestroy', () => {
    // arrange
    const resultFn = () => {
      class NoDestroyComponent implements OnInit {
        ngOnInit() { }

        @UntilOnDestroy()
        obs() {
          return of(null).subscribe();
        }
      }
    };
    // assert
    expect(resultFn).toThrowError(`You have to implements ngOnDestroy in component NoDestroyComponent`);
  });
});
